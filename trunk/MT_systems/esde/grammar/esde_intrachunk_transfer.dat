# 1			2			3				4			5		6
# descendantCond	descendantAttr		ancestorCond			ancestorAttr		direction	writeMode
# CAUTION: different descendant-ancestor conditions as it is used as unique key!!!
# --------------------------------------------------------------------------------------------------------------------------- #
# --------------------------------------------------------------------------------------------------------------------------- #
## Unknown
# Nouns
# take the morphological information (gender and number) from the source noun
my.unknown=/./&&my.smi=/NCMS/		"Masc.Sg"	my.type=/NP|PP/		mi			up		no-overwrite
my.unknown=/./&&my.smi=/NCMP/		"Masc.Pl"	my.type=/NP|PP/		mi			up		no-overwrite
my.unknown=/./&&my.smi=/NCFS/		"Fem.Sg"	my.type=/NP|PP/		mi			up		no-overwrite
my.unknown=/./&&my.smi=/NCFP/		"Fem.Pl"	my.type=/NP|PP/		mi			up		no-overwrite

# --------------------------------------------------------------------------------------------------------------------------- #
## Adverbs
# Negation
my.smi=/RN/		yes		my.type=/AVP/		neg		up		overwrite

# --------------------------------------------------------------------------------------------------------------------------- #
## Verbs
# Auxiliary: haben|sein
my.lem=haben&&my.slem=haber&&my.smi=/VA.+/	lem	my.pos=/V.PP/&&my.aux=sein	aux	down	overwrite

# modal/command verbs: special word order for past participle form (that looks like infinite form)
my.pos=/VMPP/||(my.pos=/VVPP/&&my.cmdverb=yes)	yes		my.type=/VP/		ppexcep		up	overwrite


# ES direct object => DE Dativ
# example: sigue a la hija => (er) folgt der Tochter
my.cas=Dat&&my.pos=/VV/		cas		my.type=/VP/			dobjcas			up		overwrite

# Gerund: seguir(finite form) + main_verb_es(gerund) => main_verb_de(finite form) + adv(noch)
#      <NODE ref="4" alloc="15" slem="comer" smi="VMG0000" UpCase="none" lem="essen" pos="VV" mi="Ger" ord="1">
#        <NODE ref="3" alloc="9" slem="seguir" smi="VMIP3S0" UpCase="none" lem="noch" pos="ADV" spos="VVFIN" mi="3.Sg.Pres.Ind" ord="0">
my.spos=/V.FIN/&&my.pos=ADV		spos		my.smi=/VMG/			pos			up		overwrite
my.spos=/V.FIN/&&my.pos=ADV&&my.mi=/./	mi		my.smi=/VMG/			mi			up		overwrite

# periphrases with INF
# soler + INF => FIN + gewoehnlich
#      <NODE ref="2" alloc="6" slem="recoger" smi="VMN0000" sform="recoger" UpCase="none" lem="ab|holen" pos="VVINF" mi="Inf">
#        <NODE ref="1" alloc="0" slem="soler" smi="VMIP3S0" sform="Suele" UpCase="none" lem="gewoehnlich" pos="ADV" spos="VVFIN" mi="3.Sg.Pres.Ind">
# volver + INF => FIN + wieder
#      <NODE ref="3" alloc="9" slem="comer" smi="VMN0000" sform="comer" UpCase="none" lem="essen" pos="VVINF" mi="Inf">
#        <NODE ref="1" alloc="0" slem="volver" smi="VMIP3S0" sform="Vuelve" UpCase="none" lem="zurück|gehen" pos="VVFIN" mi="3.Sg.Pres.Ind">
#        <NODE ref="2" alloc="7" slem="a" smi="SPS00" sform="a" UpCase="none" lem="" pos="APPR" adpos="a">
my.spos=/V.FIN/&&my.pos=ADV&&!(parent.slem=estar)	spos		my.smi=/VMN/&&my.pos=/V.INF/	pos			up		overwrite
my.spos=/V.FIN/&&my.pos=ADV&&parent.slem=estar		VAFIN		my.smi=/VMN/&&my.pos=/V.INF/	pos			up		overwrite
my.spos=/V.PP/&&my.pos=ADV		spos		my.smi=/VMN/&&my.pos=/V.INF/	pos			up		overwrite
my.spos=/V.FIN/&&my.pos=ADV&&my.mi=/./	mi		my.smi=/VMN/&&my.mi=Inf		mi			up		overwrite

# tener que + INF => muessen + INF (delete "que")
#     <NODE ref="7" alloc="30" slem="echar" smi="VMN0000" sform="echar" UpCase="none" lem="hinaus|werfen" pos="VVINF" mi="Inf">
#        <NODE ref="5" alloc="17" slem="tener" smi="VMIS3P0" sform="tuvieron" UpCase="none" lem="müssen" pos="VMFIN" mi="3.Pl.Past.Ind"></NODE>
#        <NODE ref="6" alloc="26" slem="que" smi="CS" sform="que" UpCase="none" lem="dass" pos="KOUS"></NODE>
my.slem=que&&lsibling.slem=/tener/	delete		my.smi=/V[ASM]N/	yes			down		overwrite

# acabar de + INF => haben_soeben + PP
#      <NODE ref="4" alloc="14" slem="comer" smi="VMN0000" UpCase="none" lem="essen" pos="VVINF" mi="Inf">
#        <NODE ref="2" alloc="5" slem="acabar" smi="VMIP3S0" UpCase="none" lem="haben" spos="VVFIN" mi="3.Sg.Pres.Ind" pos="VA">
my.spos=/V.FIN/&&my.pos=VA		pos		my.smi=/VMN/&&my.pos=VVINF	VAFIN			down		overwrite
my.spos=/V.FIN/&&my.pos=VAFIN		VVPP		my.smi=/VMN/&&my.mi=Inf		pos			up		overwrite
# llegar a ser => werden (tagged as auxiliary but as main verb)
#      <NODE ref="5" alloc="19" slem="ser" smi="VSN0000" UpCase="none" lem="sein" pos="VAINF" mi="Inf">
#        <NODE ref="3" alloc="11" slem="llegar" smi="VMIP3S0" UpCase="none" lem="werden" pos="VAFIN" mi="3.Sg.Pres.Ind">
#	...
#        <NODE ref="4" alloc="17" slem="a" smi="SPS00" UpCase="none" lem="" pos="APPR" adpos="a" delete="yes">
my.adpos=a&&my.delete=yes&&lsibling.slem=/llegar/	delete		my.smi=/VSN/	delete			up		overwrite

# importar => sein_wichtig:
#      <NODE ref="5" alloc="" slem="importar" smi="VMIP3S0" sform="importa" UpCase="none" lem="sein_wichtig" complex_pos="VA_ADJD" split="yes" spos="VAFIN" mi="3.Sg.Pres.Ind">
# after split:
#      <NODE ref="5" alloc="" slem="importar" smi="VMIP3S0" sform="importa" UpCase="none" lem="sein" spos="VAFIN" mi="3.Sg.Pres.Ind" pos="VA"></NODE>
#      <NODE ref="6" alloc="" slem="importar" smi="VMIP3S0" sform="importa" UpCase="none" lem="wichtig" spos="VAFIN" mi="3.Sg.Pres.Ind" clone="1" pos="ADJD"/>
my.spos=/VAFIN/&&my.pos=VA	pos	my.type=VP	VAFIN	down	overwrite
my.spos=/VAPP/&&my.pos=VA	pos	my.type=VP	VAPP	down	overwrite

# infinite verb clause
# para/sin + INF => um/ohne + zu + INF
#      <CHUNK ref="3" type="VZ-inf" alloc="17" si="sp-obj">
#        <NODE ref="4" alloc="17" slem="sin" smi="SPS00" sform="sin" UpCase="none" lem="ohne" pos="APPR" cas="Akk">
#          <NODE ref="5" alloc="21" slem="comer" smi="VMN0000" sform="comer" UpCase="none" lem="essen" pos="VVINF" mi="Inf">
# also with modal:
#      <CHUNK ref="3" type="VZ-inf" alloc="17" si="sp-obj">
#        <NODE ref="4" alloc="17" slem="sin" smi="SPS00" sform="sin" UpCase="none" lem="ohne" pos="APPR" cas="Akk">
#          <NODE ref="6" alloc="27" slem="comer" smi="VMN0000" sform="comer" UpCase="none" lem="essen" pos="VVINF" mi="Inf">
#            <NODE ref="5" alloc="21" slem="poder" smi="VMN0000" sform="poder" UpCase="none" lem="können" pos="VMINF" mi="Inf">
#my.pos=/V[VAM]INF/	zu			my.type=VZ-inf			yes			down		overwrite
#xpath{//CHUNK[@type="VZ-inf"]/descendant::NODE[starts-with(@pos,"V") and contains(@pos,"INF") and count(NODE[starts-with(@pos,"V")])=0]}	zu	my.type=VZ-inf			yes			down		overwrite
#xpath{//CHUNK[@type="VP-inf"]/descendant::NODE[starts-with(@pos,"V") and contains(@pos,"INF") and count(NODE[starts-with(@pos,"V")])=0]}	zu	my.type=VP-inf&&lsibling.pos=/VV/&&!(lsibling.cmdverb=/yes/)		yes			down		overwrite
xpath{//CHUNK[@type="PP"]/CHUNK[@type="VP" and @si="S"]/descendant::NODE[starts-with(@pos,"V") and contains(@pos,"INF") and count(NODE[starts-with(@pos,"V")])=0]}	zu	my.type=VP			yes			down		overwrite


##Pronouns/Clitics
# ES reflexive verbs => DE irreflexive verbs: delete reflexive pronoun
my.pos=/PRF/		delete		xpath{//CHUNK[@type="VP" and NODE[@irrefl="yes"]]/CHUNK[@type="NP"]}	yes		down		overwrite

# pronoun directly dependent of the verb (clitic) TODO: with 3rd person or separate?
# case of the 1st/2nd person pronoun clitic form is ambiguous, depends also on the verb: direct object "te veo" vs indirect "te doy algo"
#my.smi=/PP[12]C/	Akk			my.type=VP			cas			up		overwrite
my.smi=/PP[12]C/	cas			my.type=VP&&my.dobjcas=/./	dobjcas			down	overwrite

# 3rd person direct object: la/las/lo/los with parol=smi=/PP3[F|M][S|P]A00/ => cas=Akk
# already in dix!... but may depend on verb case
my.smi=/PP3..A00/	cas			my.type=VP&&my.dobjcas=/./	dobjcas			down	overwrite

# 3rd person indirect object: le/les with parol=smi=/PP3C[S|P]D00/ => cas=Dat
# already in dix!...
#my.smi=/PP3C/&&my.smi=/D00/	Dat		my.type=VP			cas			up		concat

#my.cas=/./		cas			my.type=VP||my.type=PP-von	cas			up		concat
my.lem=/./		lem			my.type=VP			headlem			up		no-overwrite


# --------------------------------------------------------------------------------------------------------------------------- #
# head preposition node of PP chunk sets the case of the whole chunk
# TODO: do the prepositions have an attribute "pos"? should it be "adpos" instead? do we need that?
my.cas=/./&&my.pos=/APPR/	cas		my.type=/PP/			cas			up		overwrite

#my.adpos=/./		adpos			my.type=PP			adpos			up		no-overwrite

# --------------------------------------------------------------------------------------------------------------------------- #
# Articles/Determiners
# delete article where semantic mark [-Art] set
my.pos=/ART/		delete		my.sem=[-Art]		yes		down		overwrite

# head NN with neutral number gets the information from determiner
# TODO: masc; only direct transfer to the chunk?
my.smi=/D..FS/				"Fem.Sg"	my.smi=/NCFN/		mi		up	overwrite
my.smi=/D..FS/&&parent.smi=/NCFN/	"Fem.Sg"	my.type=/NP|PP/		mi		up	overwrite
# --------------------------------------------------------------------------------------------------------------------------- #
# Nouns
# head NN node of NP chunk sets the gender and number of the whole chunk
my.mi=/./&&my.pos=/NN|NE/	mi			my.type=/NP|PP/			mi			up		no-overwrite
my.mi=/./&&my.pos=/PPOSS|PWS/	mi			my.type=/NP|PP/			mi			up		no-overwrite

# set case of circunstancial complements to Akk
my.pos=/NN/				Akk		my.type=/NP/&&my.si=cc			cas		up		no-overwrite
my.pos=/NN|ART|PPOSAT|PDAT|PIAT/	cas		my.type=/NP/&&my.si=cc&&my.cas=/./	cas		down		overwrite

# distinguish type of adjective: attribute (atr) to a predicate ADJD or modifier of a noun ADJA
#my.pos=/ADJ/		pos			my.type=/NP|AP|PP/&&!(my.si=atr)		ADJA		down		overwrite
my.pos=/ADJ/		pos			my.type=/NP|PP/||(my.type=AP&&!(my.si=atr))	ADJA		down		overwrite

# article/determiner/pronoun sets the flexion type of adjectives in the same chunk
# overwrite for the case of "all/dies/jen"+possessive pronoun => like after possessive pronoun, i.e. mixed
my.pos=[Z]		St			my.type=NP			flex			up		no-overwrite	# TODO: die drei kleinen?
my.flex=/./		flex			my.type=NP			flex			up		overwrite
my.pos=/ADJ/		flex			my.type=NP&&my.flex=/./		flex			down		overwrite	# TODO: no article => St; default?

# NP with flex: pass the info down thru the AP to the ADJ
my.pos=/ADJ/		flex			my.type=AP&&chunkparent.flex=/./	chunkparent.flex		down		no-overwrite
# set case of direct objects to Akk
my.pos=/ADJ/		cas			my.type=AP&&chunkparent.si=cd		Akk				down		no-overwrite


# set case of direct objects to Akk (or another case like Dat given by the head verb)
my.pos=/NN|ART|PPOSAT|PDAT|PIAT|ADJ/	cas		my.type=/NP|PP/&&my.si=cd&&chunkparent.dobjcas=/./	chunkparent.dobjcas	down		no-overwrite
my.pos=/NN|ART|PPOSAT|PDAT|PIAT|ADJ/	cas		my.type=/NP|PP/&&(my.si=cd||chunkparent.si=cd)&&!(chunkparent.dobjcas=/./)	Akk			down		no-overwrite

# set case of subjects and attributives to Nom
my.pos=/NN|ART|PPOSAT|PDAT|PIAT|ADJ/	cas		my.type=NP&&my.si=/atr|suj/	Nom			down		no-overwrite

# set number of subject PWS "wer" to singular in finite verb
my.pos=/V.FIN/		subjnum		xpath{//CHUNK[@type="VP" and CHUNK[@si="suj" and @type="NP" and NODE[@pos="PWS"]]]}	"Sg"	down	overwrite

# set case of indirect objects to Dat
#my.pos=/NN|ART|PPOSAT|PIAT|ADJ/	cas		my.type=/NP|PP/&&my.si=ci	Dat			down		no-overwrite
#my.pos=/NN|ART|PPOSAT|PIAT/		cas		my.type=/NP/&&chunkparent.cas=Dat	Dat		down		no-overwrite
#my.pos=/ADJ/				cas		my.type=/AP/&&chunkgrandparent.cas=Dat	Dat		down		no-overwrite
my.pos=/NN|ART|PPOSAT|PDAT|PIAT/		cas		my.type=/NP/&&chunkparent.cas=/./	chunkparent.cas		down		no-overwrite
my.pos=/ADJ/				cas		my.type=/AP/&&chunkgrandparent.cas=/./	chunkparent.chunkparent.cas		down		no-overwrite

# set gender (and number) of ADJ if head noun is singular
my.pos=/ADJ/			mi		my.type=/NP|PP/&&my.mi=/Sg/		mi			down		overwrite
my.pos=/ADJ/			mi		my.type=AP&&chunkparent.mi=/Sg/		chunkparent.mi		down		overwrite

# set gender and number of ART; formerly concatenated... ancestor condition alternative for multiword proper names with morphological information like "die demokratische Republik Kongo"
#my.pos=/ART|PPOSAT|PIAT|PDAT/			mi		my.type=/NP|PP/&&my.mi=/./	mi			down		concat
my.pos=/ART|PPOSAT|PIAT|PDAT/			mi		(my.type=/NP|PP/||my.smi=/NP/)&&my.mi=/./	mi			down		overwrite

# set case from preposition to nested noun, specifiers and modifiers
#not nested anymore 20130214
#my.pos=/ART|NN|PPOSAT|PIAT|PDAT|ADJ|PPER/	cas		my.pos=APPR			cas			down		overwrite

# special case: muchos de ellos NP(ellos_PPER(muchos_PI)(de_APPR)) => viele von(Dat->to up) ihnen(from down->Dat)
my.pos=APPR&&chunkparent.type=NP		cas		my.pos=/PPER/			cas			up		overwrite

# --------------------------------------------------------------------------------------------------------------------------- #
# ES object doubling
# set delete=yes to pronominal objects if there is a corresponding nominal object
my.pos=PPER&&my.smi=/PP...A../	delete		my.type=VP&&chunkchild.si=cd		yes			down		no-overwrite
my.pos=PPER&&my.smi=/PP...D../	delete		my.type=VP&&chunkchild.si=ci		yes			down		no-overwrite

# --------------------------------------------------------------------------------------------------------------------------- #
# ES relative pronoun "que" without gender/number information
my.pos=/PRELS/&&my.slem=que	mi		my.type=/S\-rel/&&chunkparent.type=/NP|PP/	chunkparent.mi			down		overwrite
#my.pos=/PRELS/&&my.slem=/que|cuyo/	mi		my.type=/S\-rel/&&chunkparent.type=/NP|PP/	chunkparent.mi			down		overwrite
my.pos=/PRELAT/&&my.slem=cuyo	mi		my.type=/S\-rel/&&chunkparent.type=/NP|PP/	chunkparent.mi			down		overwrite


# set type of "a"-PP for human direct object to NP
#-			NP			my.type=PP&&si=cd		ntype			up		overwrite


