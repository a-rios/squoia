#
# Rules to solve morphological ambiguity (e.g. es: borracho, de: betrunken/Betrunkener (adj vs noun)
#
# Format:
# nodeSRC        morphTRGT     k/d     condition            ## comment
#
# condition: if the condition evaluates to true
# -> k=keep (keep only this option), d=delete  (delete this tranlsation option from output)
# my -> this node, parent -> parent node, child -> child node (true if condition is met for at least one child node), 
# rsibling/lsibling -> right/left sibling node (true if condition is met for at least one sibling node to the right/left)
# chunkparent: first ancestor that is a chunk
# other attributes than 'mi' can be used as morphTRGT, with 'attr=value', e.g. verbmi=bla will check all syn nodes where verbmi=bla for given conditions
# if no attr is given, morphTRGT is 'mi'

# IMPORTANT: 
# - if more than one translation option with 'k' for a node evaluates to true, the first one will be used to fill 
#   the attributes of NODE, but the all others that evaluate to true will be kept as SYN nodes!
# - rules are stored in a hash, key is the combination of the node condition (1st column) and morphology attribute (3rd column in rules)
#  --> it's not possible to have more than one rule with the same node condition and the same morphology attribute!!


#TODO: funktioniert nicht
#ebrio, machaq (ser), machasqa (estar), leave for language model
my.slem=ebrio	k	VRoot+Ag	my.smi=/NC/
my.slem=ebrio	k	VRoot+Perf	my.smi=/AQ/

# aqui, ahí, allá: kay, chay, haqay +Loc if static, +Dat with movement verbs
my.slem=aquí	k	PrnDem+Loc		!(xpath{ancestor::CHUNK[@type="grup-verb" or @type="coor-v"]/NODE[@sem="[+Mov]"]})
my.slem=aquí	k	PrnDem+Dat		xpath{ancestor::CHUNK[@type="grup-verb" or @type="coor-v"]/NODE[@sem="[+Mov]"]}
my.slem=ahí	k	PrnDem+Loc		!(xpath{ancestor::CHUNK[@type="grup-verb" or @type="coor-v"]/NODE[@sem="[+Mov]"]})
my.slem=ahí	k	PrnDem+Dat		xpath{ancestor::CHUNK[@type="grup-verb" or @type="coor-v"]/NODE[@sem="[+Mov]"]}
my.slem=allá	k	PrnDem+Loc		!(xpath{ancestor::CHUNK[@type="grup-verb" or @type="coor-v"]/NODE[@sem="[+Mov]"]})
my.slem=allá	k	PrnDem+Dat		xpath{ancestor::CHUNK[@type="grup-verb" or @type="coor-v"]/NODE[@sem="[+Mov]"]}

# conmigo vs mí -> same tag, disambiguate here:
# a mí -> ++1.Sg.Obj, para/por mí -> ñuqapaq /wan etc
my.smi=PP1CSO00	k	++1.Sg.Obj			my.slem=mí && xpath{parent::CHUNK/parent::CHUNK/NODE[@slem="a"]}
my.smi=PP1CSO00	k	PrnPers				my.slem=mí && xpath{parent::CHUNK/parent::CHUNK/NODE[not(@slem="a")]}
my.smi=PP1CSO00	k	PrnPers+Instr			my.slem=conmigo

my.smi=PP2CSO00	k	++2.Sg.Obj			my.slem=tí && xpath{parent::CHUNK/parent::CHUNK/NODE[@slem="a"]}
my.smi=PP2CSO00	k	PrnPers				my.slem=tí && xpath{parent::CHUNK/parent::CHUNK/NODE[not(@slem="a")]}
my.smi=PP2CSO00	k	PrnPers+Instr			my.slem=contigo

my.smi=PP2CP000	k	++2.Pl.Obj			my.sform=os || xpath{parent::CHUNK/parent::CHUNK/NODE[@slem="a"]}
my.smi=PP2CP000	k	PrnPers				(my.slem=vosotros || my.slem=usted) && xpath{parent::CHUNK/parent::CHUNK/NODE[not(@slem="a")]}

my.smi=PP3CSO00	k	++Rflx				my.slem=sí && xpath{parent::CHUNK/parent::CHUNK/NODE[@slem="a"]}
my.smi=PP3CSO00	k	NRoot				my.slem=sí && xpath{parent::CHUNK/parent::CHUNK/NODE[not(@slem="a")]}
my.smi=PP3CSO00	k	NRoot+Instr			my.slem=consigo

my.smi=PP3CNO00	k	++Rflx				my.slem=sí && xpath{parent::CHUNK/parent::CHUNK/NODE[@slem="a"]}
my.smi=PP3CNO00	k	NRoot				my.slem=sí && xpath{parent::CHUNK/parent::CHUNK/NODE[not(@slem="a")]}
my.smi=PP3CNO00	k	NRoot+Instr			my.slem=consigo

# personal pronoun 1.Pl -> if verb is 2 pers: must be 1.pl.excl
# -> 2 > 1.pl cannot be inclusive
# nos:
my.smi=/PP1.P000/	k	++1.Pl.Excl.Obj			xpath{ancestor::CHUNK[@type="grup-verb" or @type="coor-v"][1]/descendant::NODE[contains(@verbmi,"2")]} 

# possessive pronouns 3rd person, Spanish: all 'su', qu: need number of possessor, if possessed noun is singular
# (if both possessor and possessed noun plural -> -nku +kuna -> realized as -nkuna anyway, just take singular
# singular is default, keep plural only if there's a double marked possessive with a plural possessor
# (something like 'su casa de mis tíos' in Adean Spanish)
my.smi=/^DP3/	k	++3.Pl.Poss			xpath{ancestor::CHUNK[@type="sn"]/CHUNK[@type="grup-sp"]/NODE[@slem="de"]} && xpath{ancestor::CHUNK[@type="sn"]/CHUNK[@type="grup-sp"]/CHUNK[@type="sn"]/NODE[starts-with(@smi,"NCMP") or starts-with(@smi,"NCFP") or starts-with(@smi,"NCCP") or starts-with(@smi,"PP3MP") or starts-with(@smi,"PP3FP") or starts-with(@smi,"PP3CP") or starts-with(@smi,"PP3NP")]}

my.smi=/^DP3/	k	++3.Sg.Poss			!(xpath{ancestor::CHUNK[@type="sn"]/CHUNK[@type="grup-sp"]/NODE[@slem="de"]} && xpath{ancestor::CHUNK[@type="sn"]/CHUNK[@type="grup-sp"]/CHUNK[@type="sn"]/NODE[starts-with(@smi,"NCMP") or starts-with(@smi,"NCFP") or starts-with(@smi,"NCCP") or starts-with(@smi,"PP3MP") or starts-with(@smi,"PP3FP") or starts-with(@smi,"PP3CP") or starts-with(@smi,"PP3NP")]} )



#################
#   verbs	#
#################

# all verbs: if 1.pl > 2 -> cannot be inclusive, keep only 1.pl.excl
my.smi=/^V.+1P/	d	verbmi=VRoot+1.Pl.Incl.Subj		xpath{ancestor::CHUNK[@type="grup-verb" or @type="coor-v"][1]/CHUNK/*[contains(@mi,"++2")]}

# all verb forms: if rel: delete all but obligative,perfect and agentive
my.smi=/^V/	k	agentive,perfect,obligative		chunkparent.verbform=rel:
my.smi=/^V/	k	agentive				chunkparent.verbform=rel:agentive

# all verbs: switch-reference
my.smi=/^V/	k	SS				 	chunkparent.verbform=SS
my.smi=/^V/	k	DS				 	chunkparent.verbform=DS
my.smi=/^V/	k	DS,SS				 	chunkparent.verbform=switch

# all verbs: 
# if <corpus evidentiality="indirect"> -> delete all NPst forms
# if <corpus evidentiality="direct"> -> delete all IPst forms
my.smi=/^V/	d	indirectpast		xpath{ancestor::corpus[@evidentiality="direct"]}
my.smi=/^V/	d	directpast		xpath{ancestor::corpus[@evidentiality="indirect"]}
my.smi=/^V/	d	habitualpast		!(my.slem=soler)

# infinitive: -y or -na (-> hay que hacer, tener que hacer)
# or -spa -> sin hacer -> mana ruraspa
my.smi=VMN0000	k	obligative			 	chunkparent.verbform=obligative
my.smi=VMN0000	k	SS				 	chunkparent.verbform=SS
my.smi=VMN0000	k	infinitive			 	!(chunkparent.verbform=/obligative|SS/)

#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------#

# MAIN VERBS

# relative clause -> la mujer que camina -> puriq warmi
# main clause, la mujer camina -> purin
# subordinated clause -spa (same subject) vs. -pti (same subject)

# in case this needs to be a switch reference form, but the programme failed to determine whether SS or DS -> keep those two, but delete all other otions 
#my.smi=/^VM/	d	agentive,perfect,present,obligative,future,potential,imperative			chunkparent.verbform=switch

# agentive relative clauses
#my.smi=/^VM/	k	agentive			 	chunkparent.verbform=rel:agentive

# indicative present
my.smi=/^VMIP/	k	perfect				 	chunkparent.verbform=/rel:not\.agentive|perfect/
my.smi=/^VMIP/	k	present				 	chunkparent.verbform=main
my.smi=/^VMIP/	k	obligative				chunkparent.verbform=obligative

# indicative imperfect past
my.smi=/^VMII/	k	perfect				 	chunkparent.verbform=/rel:not\.agentive|perfect/
my.smi=/^VMII/	k	obligative			 	chunkparent.verbform=obligative
# if this is 'soler' and past tense -> habitual
my.smi=/^VMII/	k	habitualpast			 	my.slem=soler
#if main clause: keep options  direct, indirect or habitual past
my.smi=/^VMII/	d	agentive,perfect,SS,DS,obligative,habitualpast	chunkparent.verbform=main && !(my.slem=soler)

# indicative past simple
my.smi=/^VMIS/	k	perfect			 		chunkparent.verbform=/rel:not\.agentive|perfect/
#if main clause: keep options  direct, indirect past
my.smi=/^VMIS/	d	agentive,perfect,SS,DS			chunkparent.verbform=main

# indicative future
my.smi=/^VMIF/	k	future					chunkparent.verbform=main
my.smi=/^VMIF/	k	obligative				chunkparent.verbform=/obligative|rel:not\.agentive/

# conditional present, TODO: relative clauses in conditional?
my.smi=/^VMIC/	k	potential				chunkparent.verbform=main
my.smi=/^VMIC/	k	obligative				chunkparent.verbform=/obligative|rel:not\.agentive/

# subjuntivo imperfecto
my.smi=/^VMSI/	k	potential				chunkparent.verbform=main && !(xpath{ancestor::CHUNK[@type="grup-verb"][2]/NODE[contains(@sem,"speech")]})
my.smi=/^VMSI/	k	imperative				chunkparent.verbform=main && ( xpath{ancestor::CHUNK[@type="grup-verb"][2]/NODE[contains(@sem,"speech")]} || xpath{parent::CHUNK[@type="grup-verb" or @type="coor-v"]/CHUNK[@type="F-term"]/NODE[@slem="!"]} )
my.smi=/^VMSI/	k	perfect				 	chunkparent.verbform=perfect	 # complement clause
my.smi=/^VMSI/	k	obligative				chunkparent.verbform=obligative

# subjuntivo present, TODO: relative clauses?
my.smi=/^VMSP/	k	perfect				 	chunkparent.verbform=perfect	 # complement clause
my.smi=/^VMSP/	k	obligative				chunkparent.verbform=/obligative|rel:not\.agentive/
# if there's a '!' present: imperative 
my.smi=/^VMSP/	k	imperative				chunkparent.verbform=main && xpath{parent::CHUNK[@type="grup-verb" or @type="coor-v"]/CHUNK[@type="F-term"]/NODE[@slem="!"]}

# main clause: potential or imperative (TODO: other options?)
my.smi=/^VMSP/	d	obligative,perfect,SS,DS		chunkparent.verbform=main

# imperative forms: ambiguous forms might be wrongly tagged
my.smi=/^VMM/	k	imperative				chunkparent.verbform=main
my.smi=/^VMM/	k	obligative				chunkparent.verbform=obligative

# special case: tener que +inf -> handled in intrachunk_transfer, delete all SYN's as they don't contain obligative as option
my.slem=tener		k	obligative					rsibling.slem=que 
my.slem=tener		d	perfect,present,DS,SS,agentive,present,future,indirectpast,potential,pastpotential,directpast,imperative	rsibling.slem=que 
# special case: deber +inf -> handled in intrachunk_transfer, delete all SYN's as they don't contain obligative as option
#my.slem=deber		k	obligative					xpath{parent::NODE/parent::CHUNK[@verbform="obligative"]}
my.slem=deber		d	perfect,present,DS,SS,agentive,present,future,indirectpast,potential,pastpotential,directpast,imperative	xpath{parent::NODE/parent::CHUNK[@verbform="obligative"]}

# if verbform=ambiguous, but verb has a PR child node -> delete all but agentive, perfect and obligative
my.smi=/^VM/		d	SS,DS,present,future,potential,imperative,indirectpast,pastpotential,directpast		chunkparent.verbform=ambiguous && xpath{child::NODE[starts-with(@smi,"PR") or NODE[starts-with(@smi,"PR") ]]}

#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------#

#################
#auxiliary verbs 
#################

# HABER

# agentive relative clause
#my.smi=/^VA/ && my.slem=haber	k	agentive				chunkparent.verbform=rel:agentive

# indicative future
my.smi=/^VAIF/ && my.slem=haber	k	obligative				chunkparent.verbform=/rel:not\.agentive|obligative/
my.smi=/^VAIF/ && my.slem=haber	k	futureDisc				chunkparent.verbform=main

# imperfect past (había hecho) -> plusquamperfect
my.smi=/^VAII/ && my.slem=haber	k	perfect					chunkparent.verbform=/rel:not\.agentive|perfect/
my.smi=/^VAII/ && my.slem=haber	k	indirectpast				chunkparent.verbform=main

# perfect past (hubo hecho)
my.smi=/^VAIS/ && my.slem=haber	k	perfect					chunkparent.verbform=/rel:not\.agentive|perfect/
# in main clause: directpast or indirectpast, delete everything else
my.smi=/^VAIS/ && my.slem=haber	d	SS,DS,agentive,perfect			chunkparent.verbform=main

# indicative present TODO: main clause, he hecho-> ruwani or ruwarani?
my.smi=/^VAIP/ && my.slem=haber	k	perfect					chunkparent.verbform=/rel:not\.agentive|perfect/
my.smi=/^VAIP/ && my.slem=haber	k	present					chunkparent.verbform=main

# subjuntivo hubiésemos/hubiéramos hecho, TODO: relative clauses??
my.smi=/^VASI/ && my.slem=haber	k	obligative				chunkparent.verbform=obligative
my.smi=/^VASI/ && my.slem=haber	k	pastpotential				chunkparent.verbform=main

# subjuntivo present: hayamos hecho, TODO: relative clause? main clause, present potential (noch nicht in dix, TODO?
my.smi=/^VASP/ && my.slem=haber	k	obligative				chunkparent.verbform=obligative
my.smi=/^VASP/ && my.slem=haber	k	potential				chunkparent.verbform=main

#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------#

# ESTAR as auxiliary (only with gerund, in all other uses: estar mi=VM)

# switch reference
my.smi=/^VA/ && my.slem=estar	k	progressive_SS					chunkparent.verbform=SS
my.smi=/^VA/ && my.slem=estar	k	progressive_DS					chunkparent.verbform=DS
my.smi=/^VM/			k	progressive_DS,progressive_SS			chunkparent.verbform=switch

# agentive relative clause
my.smi=/^VA/ && my.slem=estar	k	progressive_agentive				chunkparent.verbform=rel:agentive

# indicative future, estaremos haciendo
my.smi=/^VAIF/ && my.slem=estar	k	progressive_future				chunkparent.verbform=main
my.smi=/^VAIF/ && my.slem=estar	k	progressive_obligative				chunkparent.verbform=/rel:not\.agentive|obligative/

# past imperfect, estaba haciendo
my.smi=/^VAII/ && my.slem=estar	k	progressive_perfect				chunkparent.verbform=/rel:not\.agentive|perfect/
# main verb: progressive_directpast or progressive_indirectpast, delete everything else
my.smi=/^VAII/ && my.slem=estar	d	progressive_agentive,progressive_perfect,progressive_DS,progressive_SS		chunkparent.verbform=main

# indicative past simple, estuve haciendo
my.smi=/^VAIS/ && my.slem=estar	k	progressive_perfect				chunkparent.verbform=/rel:not\.agentive|perfect/
# main verb: progressive_directpast or progressive_indirectpast, delete everything else
my.smi=/^VAIS/ && my.slem=estar	d	progressive_agentive,progressive_perfect,progressive_DS,progressive_SS		chunkparent.verbform=main 

# indicative present
my.smi=/^VAIP/ && my.slem=estar	k	progressive_present				chunkparent.verbform=main
my.smi=/^VAIP/ && my.slem=estar	k	progressive_perfect				chunkparent.verbform=/rel:not\.agentive|perfect/

# subjuntive past, estuvieramos haciendo, TODO: relative clauses?
my.smi=/^VASI/ && my.slem=estar	k	progressive_potential				chunkparent.verbform=main

# subjuntive present, estemos haciendo, TODO: relative clauses?
my.smi=/^VASP/ && my.slem=estar	k	progressive_potential				chunkparent.verbform=main
my.smi=/^VASP/ && my.slem=estar	k	progressive_obligative				chunkparent.verbform=obligative 
my.smi=/^VASP/ && my.slem=estar	k	progressive_perfect				chunkparent.verbform=perfect	#complement

#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------#

# SER as passive or main verb (always VS)

# passive, always the same
my.smi=/^VS/ && my.slem=ser	k	passive				chunkparent.verbform=passive


# infinitive
my.smi=/^VSN0000/ && my.slem=ser	k	infinitive			!(chunkparent.verbform=passive)&&!(chunkparent.verbform=obligative)
my.smi=/^VSN0000/ && my.slem=ser	k	obligative			chunkparent.verbform=obligative

# conditional
my.smi=/^VSIC/ && my.slem=ser	k	potential			chunkparent.verbform=main

# future
my.smi=/^VSIF/ && my.slem=ser	k	future				chunkparent.verbform=main
my.smi=/^VSIF/ && my.slem=ser	k	obligative			chunkparent.verbform=/obligative|rel:not\.agentive/

# past imperfect
my.smi=/^VSII/ && my.slem=ser	k	perfect				chunkparent.verbform=/rel:not\.agentive|perfect/
# if this is 'soler' and past tense -> habitual
my.smi=/^VSII/			k	habitualpast			 my.slem=soler && chunkparent.verbform=main
# main verb: directpast, indirectpast or habitual past, delete everything else
my.smi=/^VSII/ && my.slem=ser	k	indirectpast,directpast		chunkparent.verbform=main && !(my.slem=soler)

# present
my.smi=/^VSIP/ && my.slem=ser	k	present				chunkparent.verbform=main
my.smi=/^VSIP/ && my.slem=ser	k	perfect				chunkparent.verbform=/rel:not\.agentive|perfect/

# subjuntive present
my.smi=/^VSSP/ && my.slem=ser	k	perfect				chunkparent.verbform=/rel:not\.agentive|perfect/
my.smi=/^VSSP/&& my.slem=ser	k	potential			chunkparent.verbform=main  && !(xpath{parent::CHUNK[@type="grup-verb" or @type="coor-v"]/CHUNK[@type="F-term"]/NODE[@slem="!"]})
my.smi=/^VSSP/&& my.slem=ser	k	obligative			chunkparent.verbform=obligative
my.smi=/^VSSP/&& my.slem=ser	k	imperative			chunkparent.verbform=main  && xpath{parent::CHUNK[@type="grup-verb" or @type="coor-v"]/CHUNK[@type="F-term"]/NODE[@slem="!"]}
     
# simple past
my.smi=/^VSIS/ && my.slem=ser	k	perfect				chunkparent.verbform=/rel:not\.agentive|perfect/
my.smi=/^VSIS/&& my.slem=ser	k	directpast,indirectpast		chunkparent.verbform=main

# subjuntive past
my.smi=/^VSSI/ && my.slem=ser	k	obligative			chunkparent.verbform=/rel:not\.agentive|obligative/		#complement 'quisera que se fuera a casa'
my.smi=/^VSSI/ && my.slem=ser	k	perfect				chunkparent.verbform=perfect		#complement
my.smi=/^VSSI/ && my.slem=ser	k	potential			chunkparent.verbform=main

# participle sido: había sido cansado vs había sido pegado
my.smi=/^VSP00S/ && my.slem=ser	k	passive				chunkparent.verbform=passive
my.smi=/^VSP00S/ && my.slem=ser	k	participle			!(chunkparent.verbform=passive)

#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
